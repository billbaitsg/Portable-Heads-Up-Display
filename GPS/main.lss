
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000240  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000056  00800060  00800060  000002b4  2**0
                  ALLOC
  2 .debug_aranges 00000060  00000000  00000000  000002b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000199  00000000  00000000  00000314  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000040c  00000000  00000000  000004ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000221  00000000  00000000  000008b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000003c5  00000000  00000000  00000ada  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000140  00000000  00000000  00000ea0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000001fe  00000000  00000000  00000fe0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000046  00000000  00000000  000011de  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	1f c0       	rjmp	.+62     	; 0x42 <__bad_interrupt>
   4:	1e c0       	rjmp	.+60     	; 0x42 <__bad_interrupt>
   6:	1d c0       	rjmp	.+58     	; 0x42 <__bad_interrupt>
   8:	1c c0       	rjmp	.+56     	; 0x42 <__bad_interrupt>
   a:	1b c0       	rjmp	.+54     	; 0x42 <__bad_interrupt>
   c:	1a c0       	rjmp	.+52     	; 0x42 <__bad_interrupt>
   e:	d8 c0       	rjmp	.+432    	; 0x1c0 <__vector_7>
  10:	0b c1       	rjmp	.+534    	; 0x228 <__vector_8>
  12:	00 c1       	rjmp	.+512    	; 0x214 <__vector_9>
  14:	16 c0       	rjmp	.+44     	; 0x42 <__bad_interrupt>
  16:	15 c0       	rjmp	.+42     	; 0x42 <__bad_interrupt>
  18:	14 c0       	rjmp	.+40     	; 0x42 <__bad_interrupt>
  1a:	16 c0       	rjmp	.+44     	; 0x48 <__vector_13>
  1c:	12 c0       	rjmp	.+36     	; 0x42 <__bad_interrupt>
  1e:	1f c0       	rjmp	.+62     	; 0x5e <__vector_15>
  20:	28 c0       	rjmp	.+80     	; 0x72 <__vector_16>
  22:	0f c0       	rjmp	.+30     	; 0x42 <__bad_interrupt>
  24:	0e c0       	rjmp	.+28     	; 0x42 <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf ed       	ldi	r28, 0xDF	; 223
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_clear_bss>:
  2e:	10 e0       	ldi	r17, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	01 c0       	rjmp	.+2      	; 0x38 <.do_clear_bss_start>

00000036 <.do_clear_bss_loop>:
  36:	1d 92       	st	X+, r1

00000038 <.do_clear_bss_start>:
  38:	a6 3b       	cpi	r26, 0xB6	; 182
  3a:	b1 07       	cpc	r27, r17
  3c:	e1 f7       	brne	.-8      	; 0x36 <.do_clear_bss_loop>
  3e:	02 d0       	rcall	.+4      	; 0x44 <main>
  40:	fd c0       	rjmp	.+506    	; 0x23c <_exit>

00000042 <__bad_interrupt>:
  42:	de cf       	rjmp	.-68     	; 0x0 <__vectors>

00000044 <main>:
	
	/* Initialize software modules */
	//USI_SPI_initslave();	/* Initialize SPI as slave */
	//UART_init();			/* Initialize UART for 9600, 8N1 */
	
	sei();	/* Enable global interrupts */
  44:	78 94       	sei
  46:	ff cf       	rjmp	.-2      	; 0x46 <main+0x2>

00000048 <__vector_13>:
 *  results in one clock period on the clock pin and for the USI counter.
 */
/*#pragma vector=TIMER0_COMP_vect */	/* Compiler specific directive */
/*__interrupt void timer0comp_handler()*/
ISR(TIMER0_COMPA_vect)
{
  48:	1f 92       	push	r1
  4a:	0f 92       	push	r0
  4c:	0f b6       	in	r0, 0x3f	; 63
  4e:	0f 92       	push	r0
  50:	11 24       	eor	r1, r1
	USICR |= (1<<USITC);	// Toggle clock output pin.
  52:	68 9a       	sbi	0x0d, 0	; 13
}
  54:	0f 90       	pop	r0
  56:	0f be       	out	0x3f, r0	; 63
  58:	0f 90       	pop	r0
  5a:	1f 90       	pop	r1
  5c:	18 95       	reti

0000005e <__vector_15>:

/* USI SPI start condition interrupt */
ISR(USI_START_vect)
{
  5e:	1f 92       	push	r1
  60:	0f 92       	push	r0
  62:	0f b6       	in	r0, 0x3f	; 63
  64:	0f 92       	push	r0
  66:	11 24       	eor	r1, r1
	/* not enabled */
}
  68:	0f 90       	pop	r0
  6a:	0f be       	out	0x3f, r0	; 63
  6c:	0f 90       	pop	r0
  6e:	1f 90       	pop	r1
  70:	18 95       	reti

00000072 <__vector_16>:
 *  For all modes the USIDR contents are stored and flags are updated.
 */
/*#pragma vector=USI_OVF_vect*/	/* Compiler specific directive */
/*__interrupt void usiovf_handler()*/
ISR(USI_OVERFLOW_vect)
{
  72:	1f 92       	push	r1
  74:	0f 92       	push	r0
  76:	0f b6       	in	r0, 0x3f	; 63
  78:	0f 92       	push	r0
  7a:	11 24       	eor	r1, r1
  7c:	8f 93       	push	r24
	// Master must now disable the compare match interrupt
	// to prevent more USI counter clocks.
	if( USI_SPI_status.masterMode == 1 ) {
  7e:	80 91 62 00 	lds	r24, 0x0062
  82:	80 ff       	sbrs	r24, 0
  84:	03 c0       	rjmp	.+6      	; 0x8c <__vector_16+0x1a>
		TIMSK &= ~(1<<OCIE0A);
  86:	89 b7       	in	r24, 0x39	; 57
  88:	8e 7f       	andi	r24, 0xFE	; 254
  8a:	89 bf       	out	0x39, r24	; 57
	}
	
	// Update flags and clear USI counter
	USISR = (1<<USIOIF);
  8c:	80 e4       	ldi	r24, 0x40	; 64
  8e:	8e b9       	out	0x0e, r24	; 14
	USI_SPI_status.transferComplete = 1;
  90:	80 91 62 00 	lds	r24, 0x0062
  94:	82 60       	ori	r24, 0x02	; 2
  96:	80 93 62 00 	sts	0x0062, r24

	// Copy USIDR to buffer to prevent overwrite on next transfer.
	storedUSIDR = USIDR;
  9a:	8f b1       	in	r24, 0x0f	; 15
  9c:	80 93 63 00 	sts	0x0063, r24
}
  a0:	8f 91       	pop	r24
  a2:	0f 90       	pop	r0
  a4:	0f be       	out	0x3f, r0	; 63
  a6:	0f 90       	pop	r0
  a8:	1f 90       	pop	r1
  aa:	18 95       	reti

000000ac <USI_SPI_initmaster>:
 *  \param spi_mode  Required SPI mode, must be 0 or 1.
 */
void USI_SPI_initmaster(void)
{
	// Configure port directions.
	USI_DIR_REG |= (1<<USI_DATAOUT_PIN) | (1<<USI_CLOCK_PIN); // Outputs.
  ac:	87 b3       	in	r24, 0x17	; 23
  ae:	80 6c       	ori	r24, 0xC0	; 192
  b0:	87 bb       	out	0x17, r24	; 23
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN);                      // Inputs.
  b2:	bd 98       	cbi	0x17, 5	; 23
	USI_OUT_REG |= (1<<USI_DATAIN_PIN);                       // Pull-ups.
  b4:	c5 9a       	sbi	0x18, 5	; 24
	
	// Configure USI to 3-wire master mode with overflow interrupt.
	USICR = (1<<USIOIE) | (1<<USIWM0) |
  b6:	8a e5       	ldi	r24, 0x5A	; 90
  b8:	8d b9       	out	0x0d, r24	; 13
	        (1<<USICS1) | (SPI_MODE<<USICS0) |
	        (1<<USICLK);

	// Enable 'Clear Timer on Compare match' and init prescaler.
	TCCR0A = (1<<WGM01);
  ba:	82 e0       	ldi	r24, 0x02	; 2
  bc:	80 bf       	out	0x30, r24	; 48
	TCCR0B = TC0_PS_SETTING;
  be:	83 bf       	out	0x33, r24	; 51
	
	// Init Output Compare Register.
	OCR0A = TC0_COMPARE_VALUE;
  c0:	83 e0       	ldi	r24, 0x03	; 3
  c2:	86 bf       	out	0x36, r24	; 54
	
	// Init driver status register.
	USI_SPI_status.masterMode       = 1;
  c4:	80 91 62 00 	lds	r24, 0x0062
  c8:	81 60       	ori	r24, 0x01	; 1
  ca:	80 93 62 00 	sts	0x0062, r24
	USI_SPI_status.transferComplete = 0;
  ce:	80 91 62 00 	lds	r24, 0x0062
  d2:	8d 7f       	andi	r24, 0xFD	; 253
  d4:	80 93 62 00 	sts	0x0062, r24
	USI_SPI_status.writeCollision   = 0;
  d8:	80 91 62 00 	lds	r24, 0x0062
  dc:	8b 7f       	andi	r24, 0xFB	; 251
  de:	80 93 62 00 	sts	0x0062, r24
	
	storedUSIDR = 0;
  e2:	10 92 63 00 	sts	0x0063, r1
}
  e6:	08 95       	ret

000000e8 <USI_SPI_initslave>:
 *  \param spi_mode  Required SPI mode, must be 0 or 1.
 */
void USI_SPI_initslave(void)
{
	// Configure port directions.
	USI_DIR_REG |= (1<<USI_DATAOUT_PIN);                      // Outputs.
  e8:	be 9a       	sbi	0x17, 6	; 23
	USI_DIR_REG &= ~(1<<USI_DATAIN_PIN) | (1<<USI_CLOCK_PIN); // Inputs.
  ea:	bd 98       	cbi	0x17, 5	; 23
	USI_OUT_REG |= (1<<USI_DATAIN_PIN) | (1<<USI_CLOCK_PIN);  // Pull-ups.
  ec:	88 b3       	in	r24, 0x18	; 24
  ee:	80 6a       	ori	r24, 0xA0	; 160
  f0:	88 bb       	out	0x18, r24	; 24
	
	// Configure USI to 3-wire slave mode with overflow interrupt.
	USICR = (1<<USIOIE) | (1<<USIWM0) |
  f2:	88 e5       	ldi	r24, 0x58	; 88
  f4:	8d b9       	out	0x0d, r24	; 13
	        (1<<USICS1) | (SPI_MODE<<USICS0);
	
	// Init driver status register.
	USI_SPI_status.masterMode       = 0;
  f6:	80 91 62 00 	lds	r24, 0x0062
  fa:	8e 7f       	andi	r24, 0xFE	; 254
  fc:	80 93 62 00 	sts	0x0062, r24
	USI_SPI_status.transferComplete = 0;
 100:	80 91 62 00 	lds	r24, 0x0062
 104:	8d 7f       	andi	r24, 0xFD	; 253
 106:	80 93 62 00 	sts	0x0062, r24
	USI_SPI_status.writeCollision   = 0;
 10a:	80 91 62 00 	lds	r24, 0x0062
 10e:	8b 7f       	andi	r24, 0xFB	; 251
 110:	80 93 62 00 	sts	0x0062, r24
	
	storedUSIDR = 0;
 114:	10 92 63 00 	sts	0x0063, r1
}
 118:	08 95       	ret

0000011a <USI_SPI_putc>:
 *  and return without altering the data registers.
 *
 *  \returns  0 if a write collision occurred, 1 otherwise.
 */
char USI_SPI_putc( unsigned char val )
{
 11a:	28 2f       	mov	r18, r24
	// Check if transmission in progress,
	// i.e. USI counter unequal to zero.
	if( (USISR & 0x0F) != 0 ) {
 11c:	8e b1       	in	r24, 0x0e	; 14
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	8f 70       	andi	r24, 0x0F	; 15
 122:	90 70       	andi	r25, 0x00	; 0
 124:	89 2b       	or	r24, r25
 126:	31 f0       	breq	.+12     	; 0x134 <USI_SPI_putc+0x1a>
		// Indicate write collision and return.
		USI_SPI_status.writeCollision = 1;
 128:	80 91 62 00 	lds	r24, 0x0062
 12c:	84 60       	ori	r24, 0x04	; 4
 12e:	80 93 62 00 	sts	0x0062, r24
 132:	08 95       	ret
		return;
	}
	
	// Reinit flags.
	USI_SPI_status.transferComplete = 0;
 134:	80 91 62 00 	lds	r24, 0x0062
 138:	8d 7f       	andi	r24, 0xFD	; 253
 13a:	80 93 62 00 	sts	0x0062, r24
	USI_SPI_status.writeCollision = 0;
 13e:	80 91 62 00 	lds	r24, 0x0062
 142:	8b 7f       	andi	r24, 0xFB	; 251
 144:	80 93 62 00 	sts	0x0062, r24

	// Put data in USI data register.
	USIDR = val;
 148:	2f b9       	out	0x0f, r18	; 15
	
	// Master should now enable compare match interrupts.
	if( USI_SPI_status.masterMode == 1 ) {
 14a:	80 91 62 00 	lds	r24, 0x0062
 14e:	80 ff       	sbrs	r24, 0
 150:	06 c0       	rjmp	.+12     	; 0x15e <USI_SPI_putc+0x44>
		TIFR |= (1<<OCF0A);   // Clear compare match flag.
 152:	88 b7       	in	r24, 0x38	; 56
 154:	81 60       	ori	r24, 0x01	; 1
 156:	88 bf       	out	0x38, r24	; 56
		TIMSK |= (1<<OCIE0A); // Enable compare match interrupt.
 158:	89 b7       	in	r24, 0x39	; 57
 15a:	81 60       	ori	r24, 0x01	; 1
 15c:	89 bf       	out	0x39, r24	; 57
	}

	if( USI_SPI_status.writeCollision == 0 ) return 1;
 15e:	80 91 62 00 	lds	r24, 0x0062
 162:	86 95       	lsr	r24
 164:	86 95       	lsr	r24
 166:	80 95       	com	r24
 168:	81 70       	andi	r24, 0x01	; 1
	return 0;
}
 16a:	08 95       	ret

0000016c <USI_SPI_getc>:
 *  like you would read from the SPDR register in the native SPI module.
 */
unsigned char USI_SPI_getc(void)
{
	return storedUSIDR;
}
 16c:	80 91 63 00 	lds	r24, 0x0063
 170:	08 95       	ret

00000172 <USI_SPI_wait>:
 *  This function waits until the transfer complete flag is set.
 *  Use this function like you would wait for the native SPI interrupt flag.
 */
void USI_SPI_wait(void)
{
	do {} while( USI_SPI_status.transferComplete == 0 );
 172:	80 91 62 00 	lds	r24, 0x0062
 176:	81 ff       	sbrs	r24, 1
 178:	fc cf       	rjmp	.-8      	; 0x172 <USI_SPI_wait>
}
 17a:	08 95       	ret

0000017c <USI_SPI_puts>:

/* Sends out a string of SPI data */
void USI_SPI_puts(char * string )
{
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
 180:	ec 01       	movw	r28, r24
 182:	02 c0       	rjmp	.+4      	; 0x188 <USI_SPI_puts+0xc>
	while(*string)	/* While there are still characters left */
	{
		USI_SPI_putc(*string++);	/* Send out the current character and increment */
 184:	21 96       	adiw	r28, 0x01	; 1
 186:	c9 df       	rcall	.-110    	; 0x11a <USI_SPI_putc>
}

/* Sends out a string of SPI data */
void USI_SPI_puts(char * string )
{
	while(*string)	/* While there are still characters left */
 188:	88 81       	ld	r24, Y
 18a:	88 23       	and	r24, r24
 18c:	d9 f7       	brne	.-10     	; 0x184 <USI_SPI_puts+0x8>
	{
		USI_SPI_putc(*string++);	/* Send out the current character and increment */
	}/* End of while */
	return;
 18e:	df 91       	pop	r29
 190:	cf 91       	pop	r28
 192:	08 95       	ret

00000194 <UART_init>:
void UART_init( void )
{
	/* UBRR = (fosc/16/baud)-1 = (8MHz/16/9600bps)-1 = 51.083 = 51 */
	unsigned int ubrr = 51;
	/* Set baud rate */
	UBRRH = (unsigned char)(ubrr>>8);
 194:	12 b8       	out	0x02, r1	; 2
	UBRRL = (unsigned char)ubrr;
 196:	83 e3       	ldi	r24, 0x33	; 51
 198:	89 b9       	out	0x09, r24	; 9
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);
 19a:	88 e1       	ldi	r24, 0x18	; 24
 19c:	8a b9       	out	0x0a, r24	; 10
	/* Set frame format: 8 data, 1 stop bit */
	UCSRC = (0<<USBS)|(3<<UCSZ0);
 19e:	86 e0       	ldi	r24, 0x06	; 6
 1a0:	83 b9       	out	0x03, r24	; 3
	/* Enable the USART Recieve Complete interrupt (USART_RXC) */
	UCSRB |= (1<<RXCIE);	
 1a2:	57 9a       	sbi	0x0a, 7	; 10
}
 1a4:	08 95       	ret

000001a6 <UART_putc>:

/* Send a byte via UART, from datasheet */
void UART_putc( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
 1a6:	5d 9b       	sbis	0x0b, 5	; 11
 1a8:	fe cf       	rjmp	.-4      	; 0x1a6 <UART_putc>
	/* Put data into buffer, sends the data */
	UDR = data;
 1aa:	8c b9       	out	0x0c, r24	; 12
}
 1ac:	08 95       	ret

000001ae <UART_getc>:

/* Get a byte via UART, from datasheet */
unsigned char UART_getc( void )
{
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
 1ae:	5f 9b       	sbis	0x0b, 7	; 11
 1b0:	fe cf       	rjmp	.-4      	; 0x1ae <UART_getc>
	/* Get and return received data from buffer */
	return UDR;
 1b2:	8c b1       	in	r24, 0x0c	; 12
}
 1b4:	08 95       	ret

000001b6 <UART_flush>:

/* Flush out the UART receive buffer, from datasheet */
void UART_flush( void )
{
 1b6:	01 c0       	rjmp	.+2      	; 0x1ba <UART_flush+0x4>
	unsigned char dummy;
	while ( UCSRA & (1<<RXC) ) dummy = UDR;
 1b8:	8c b1       	in	r24, 0x0c	; 12
 1ba:	5f 99       	sbic	0x0b, 7	; 11
 1bc:	fd cf       	rjmp	.-6      	; 0x1b8 <UART_flush+0x2>
}
 1be:	08 95       	ret

000001c0 <__vector_7>:

/* UART receive complete interrupt */
ISR( USART_RX_vect )
{
 1c0:	1f 92       	push	r1
 1c2:	0f 92       	push	r0
 1c4:	0f b6       	in	r0, 0x3f	; 63
 1c6:	0f 92       	push	r0
 1c8:	11 24       	eor	r1, r1
 1ca:	8f 93       	push	r24
 1cc:	9f 93       	push	r25
 1ce:	ef 93       	push	r30
 1d0:	ff 93       	push	r31
	/* Wait for completion of transmit (should be redundant) */
	while ( !(UCSRA & (1<<RXC)) );	
 1d2:	5f 9b       	sbis	0x0b, 7	; 11
 1d4:	fe cf       	rjmp	.-4      	; 0x1d2 <__vector_7+0x12>
	/* if BUFFER_SIZE is reached, reset to start of buffer */
	if (UART_BUF_CNT==UART_BUFFER_SIZE) 
 1d6:	80 91 60 00 	lds	r24, 0x0060
 1da:	82 35       	cpi	r24, 0x52	; 82
 1dc:	11 f4       	brne	.+4      	; 0x1e2 <__vector_7+0x22>
	{
		UART_BUF_CNT=0;
 1de:	10 92 60 00 	sts	0x0060, r1
	}/* End of if */
	/* Put character in buffer and increment counter */
	UART_BUFFER[UART_BUF_CNT++] = UDR;
 1e2:	80 91 60 00 	lds	r24, 0x0060
 1e6:	e8 2f       	mov	r30, r24
 1e8:	f0 e0       	ldi	r31, 0x00	; 0
 1ea:	9c b1       	in	r25, 0x0c	; 12
 1ec:	ec 59       	subi	r30, 0x9C	; 156
 1ee:	ff 4f       	sbci	r31, 0xFF	; 255
 1f0:	90 83       	st	Z, r25
 1f2:	8f 5f       	subi	r24, 0xFF	; 255
 1f4:	80 93 60 00 	sts	0x0060, r24
	/* Put up UART recieve byte complete flag */
	UART_FLAGS |= (1<<UART_RXC);	
 1f8:	80 91 61 00 	lds	r24, 0x0061
 1fc:	81 60       	ori	r24, 0x01	; 1
 1fe:	80 93 61 00 	sts	0x0061, r24
}
 202:	ff 91       	pop	r31
 204:	ef 91       	pop	r30
 206:	9f 91       	pop	r25
 208:	8f 91       	pop	r24
 20a:	0f 90       	pop	r0
 20c:	0f be       	out	0x3f, r0	; 63
 20e:	0f 90       	pop	r0
 210:	1f 90       	pop	r1
 212:	18 95       	reti

00000214 <__vector_9>:

/* UART transmit complete interrupt */
ISR( USART_TX_vect )
{
 214:	1f 92       	push	r1
 216:	0f 92       	push	r0
 218:	0f b6       	in	r0, 0x3f	; 63
 21a:	0f 92       	push	r0
 21c:	11 24       	eor	r1, r1
	
}
 21e:	0f 90       	pop	r0
 220:	0f be       	out	0x3f, r0	; 63
 222:	0f 90       	pop	r0
 224:	1f 90       	pop	r1
 226:	18 95       	reti

00000228 <__vector_8>:

/* UART data register empty */
ISR( USART_UDRE_vect )
{
 228:	1f 92       	push	r1
 22a:	0f 92       	push	r0
 22c:	0f b6       	in	r0, 0x3f	; 63
 22e:	0f 92       	push	r0
 230:	11 24       	eor	r1, r1

 232:	0f 90       	pop	r0
 234:	0f be       	out	0x3f, r0	; 63
 236:	0f 90       	pop	r0
 238:	1f 90       	pop	r1
 23a:	18 95       	reti

0000023c <_exit>:
 23c:	f8 94       	cli

0000023e <__stop_program>:
 23e:	ff cf       	rjmp	.-2      	; 0x23e <__stop_program>
